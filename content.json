[{"title":"sublime安装后遇到的问题","date":"2020-09-15T13:24:20.880Z","path":"2020/09/15/sublime安装后遇到的问题/","text":"sublime安装后遇到的问题在写Html网页的时候出现按tab键无法快速生成格式的问题操作方法： 先是右下角一定要选择HTML 然后网页保存为html格式（要是在创建之后就保存了，就跳过这个步骤） 输入html 然后按Tab，就可以生成基本的html框架啦 关于emmet的安装问题这里引用一个别人的博客：https://www.cnblogs.com/carrie-hong/p/4995735.html 安装以上步骤基本上都可以解决哦，安装成功后没反应可以重新开启一下sublime text 3或者更新一下，亲测有效。","tags":[]},{"title":"python爬虫实战教学指南(1)","date":"2020-07-19T09:01:55.381Z","path":"2020/07/19/爬虫-汽车销量排行榜/","text":"如何爬取一个网页？数据的处理和分析是后话，先要获取到数据吧，在python中有urllib, httplib2, requests等一些库。 这里将展示使用requests来爬取网页。 12345678910111213141516import requests# 构造一个可以获取单个网页的函数def get_one_page(url): # 函数的传入值是一个网页的地址 headers = &#123; &#125; response = requests.get(url, headers = headers) # 调用requests的get方法，第一个填网页的地址url,第二个填写headers,也就是头文件信息 print(response) # 构造一个主函数def main(): url = \"\" # 引号内可以填上任何网页链接 print( get_one_page(url) ) if __name__ == '__main__': main() 以上是爬取网页的一个基本的操作，可以很快的获取网页的源代码，但是并没有做处理。 下面是对网页做一个简单的提取，这里用的是正则表达式的方法，访问的网页是汽车销量的排行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import requestsimport reimport jsonimport time# 获取单页的网页信息def get_one_page(url): # 函数的传入是网页的url,也就是网址 # 对请求头部的伪装 headers = &#123; 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.162 Safari/537.36' &#125; response = requests.get(url, headers = headers) # get中存在headers参数，传入的是我们刚刚写的headers if response.status_code == 200: return response.text return None# 解析网页的方法def parse_one_page(html): pattern = re.compile('&lt;tr&gt;.*?class=\"top\"&gt;(.*?)&lt;/em&gt;.*?/\"&gt;(.*?)&lt;/a&gt;', re.S) items = re.findall(pattern, html) for item in items: yield &#123; # 可以吧yield理解为return,就是返回值 '名次': item[0], '车名': item[1] &#125;# 将字典的内容写入文件当中def write_to_file(content): with open('result.txt', 'a', encoding='utf-8') as f: f.write(json.dumps(content, ensure_ascii=False) + '\\n')# 主函数这里主要用来提供url以及调用其他的函数def main(num): url = 'https://top.16888.com/auto_rq4_' + str(num) + '.html' html = get_one_page(url) for item in parse_one_page(html): print(item) write_to_file(item)if __name__ == '__main__': for num in range(10): main(num) time.sleep(1) # 设置访问的间隔，避免被反爬虫 运行后在终端得到的结果（同时内容会被写进result.txt文件当中)：","tags":[{"name":"python爬虫","slug":"python爬虫","permalink":"http://yoursite.com/tags/python%E7%88%AC%E8%99%AB/"}]},{"title":"封装案例","date":"2020-04-06T06:00:53.857Z","path":"2020/04/06/封装案例/","text":"封装案例123456789101112131415161718192021222324252627282930313233343536class HouseItem: #需要被使用的类要先开发 def __init__(self, name, area): self.name = name self.area = area def __str__(self): return \"%s\" % self.nameclass House: def __init__(self, house_type, area): self.house_type = house_type self.area = area self.freearea = area self.item_list = [] def add_item(self, item): self.item_list.append(item.name) if self.freearea &gt; item.area: self.freearea -= item.area else: print(\"%s 面积太大,房间剩余空间不足\" % item.name) def __str__(self): return \"户型：%s\\n总面积: %.2f\\n剩余面积: %.2f\\n家具有:%s\" % (self.house_type, self.area, self.freearea, self.item_list)wjjhouse = House(\"三室两厅\", 150)bed = HouseItem(\"席梦思\", 4)chest = HouseItem(\"衣柜\", 2)table = HouseItem(\"餐桌\", 1.5)wjjhouse.add_item(bed)wjjhouse.add_item(chest)wjjhouse.add_item(table)print(wjjhouse)","tags":[]},{"title":"python格式化输出","date":"2020-04-01T02:59:17.535Z","path":"2020/04/01/python格式化输出/","text":"python格式化输出1.print12print(\"%s (%s)\" % (name, title))#在python中可以用%来格式化输出，这里有点像c语言 然而，默认下，print的输出后是换行的 2.输出不想换行怎么办？12print(\"hello world\", end=\"\") #这么写就不会换行输出print(\"hello world\", end=\" \") #这么写会在结尾处加“空格”","tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"python的逻辑运算符","date":"2020-04-01T02:59:14.628Z","path":"2020/04/01/python的逻辑运算符/","text":"python的逻辑运算符12345and , or , not and 同时满足or 或者not 非常用于 if not ...: #如果不是怎么怎么样","tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"python随机数的产生","date":"2020-04-01T02:59:12.802Z","path":"2020/04/01/python随机整数产生/","text":"python随机整数产生123import randomfor i in range(20): print(random.randint(10, 1000)) #可以产生10到1000的随机整数，并且换行","tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"python中列表遍历","date":"2020-04-01T02:59:11.153Z","path":"2020/04/01/列表的遍历/","text":"列表的遍历在python中，为了方便书写的效率，提供了迭代遍历，具体例子如下： 如果我需要遍历一个列表（数组）,这里用keyword.kwlist这个列表举例子，可以这么做： 12345import keyword #加载关键字库#keyword.kwlist 返回的是一个列表类型，里面放着python的35个关键字#以下给出遍历的方法for k_word in keyword.kwlist: print(k_word)","tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"九九乘法表","date":"2020-04-01T02:59:08.774Z","path":"2020/04/01/九九乘法表的实现/","text":"九九乘法表的实现1九九乘法表在讲循环的时候全部都学过，这里会用两种思路来实现，基础的东西很重要！ 1.for语句两层循环输出12345for i in range(9): for j in range(9): if j &lt;= i: print(\"%d * %d = %d\" % (j+1, i+1, (i+1)*(j+1)), end=\"\\t\") print(\"\") 2.while语句，利用行数和列数的关系12345678row = 1; #行数初始化为1while row &lt;= 9: col = 1; #将列数重置为1 while row &lt;= col: #如果列数小于行数 print(\"%d * %d = %d\" % (row, col, row*col), end=\"\\t\") col += 1 #列数加1 print(\"\") row += 1 #行数加1","tags":[{"name":"编程基本功","slug":"编程基本功","permalink":"http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E5%8A%9F/"}]},{"title":"查看python关键字","date":"2020-04-01T02:58:47.955Z","path":"2020/04/01/查看python关键字/","text":"查看python关键字12import keywordprint( keyword.kwlist )","tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"python爬虫-中国大学排名实例","date":"2020-03-28T15:26:13.719Z","path":"2020/03/28/python爬虫(2)/","text":"## 标签树的上行遍历 12345678910111213import requestsfrom bs4 import BeautifulSoupr = requests.get( \"http://python123.io/ws/demo.html\")demo = r.textprint(demo)soup = BeautifulSoup( demo, \"html.parser\")for parent in soup.a.parents: if parent is None: print(parent) else: print(parent.name) 标签书的平行遍历平行遍历必须发生在同一个父亲节点下 后续节点 1234for sibling in soup.a.next_siblings: print(sibling)for sibling in soup.a.previous_siblings: print(sibling) 下行遍历：.contents .children .descendants上行遍历: .parent .parents平行遍历：.next_sibling .previous_siblings .next_siblings .previous_siblings 把html排列整齐：1soup.prettify() 信息标记与提取的方法123.find_all(name, attrs, recursive,string)&lt;tag&gt;()等价于&lt;tag&gt;.find_all()soup()等价于soup.find_all() 实战：中国大学排名获取思路：1.先在tbody标签中获得所有的大学的信息2.然后再tr标签中找到td3.把每个大学的数据写到我们的list中 1234567891011121314151617181920212223242526272829303132333435#CrawUnivRankingA.pyimport requestsfrom bs4 import BeautifulSoupimport bs4def getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return \"\"def fillUnivList(ulist, html): soup = BeautifulSoup(html, \"html.parser\") for tr in soup.find('tbody').children: if isinstance(tr, bs4.element.Tag): tds = tr('td') ulist.append([tds[0].string, tds[1].string, tds[2].string])def printUnivList(ulist, num): tplt = \"&#123;0:^10&#125;\\t&#123;1:&#123;3&#125;^10&#125;\\t&#123;2:^10&#125;\"//解决中文对其问题 print(tplt.format(\"排名\",\"学校名称\",\"总分\",chr(12288))) for i in range(num): u=ulist[i] print(tplt.format(u[0],u[1],u[2],chr(12288))) def main(): uinfo = [] url = 'http://www.zuihaodaxue.cn/zuihaodaxuepaiming2019.html' html = getHTMLText(url) fillUnivList(uinfo, html) printUnivList(uinfo, 400) # 20 univsmain() 因为当我们大默认字符长度不够的时候，python默认用西文字符的空格来填充，如果要中文字符填充的话就需要修改。","tags":[{"name":"python爬虫","slug":"python爬虫","permalink":"http://yoursite.com/tags/python%E7%88%AC%E8%99%AB/"}]},{"title":"C++(4)","date":"2020-03-27T14:54:52.259Z","path":"2020/03/27/C++(4)/","text":"## new 这个东西的横空出世，把malloc彻底干掉了现在，我要是想在堆区申请一块空间，只需要这么做 1Person* person = new Person; 那么释放的话需要这么做呢？ 1delete person; 通过new开辟数组 1Person* person = new Person[10]; 释放new开辟的数组 1delete [] person;","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"python爬虫第一篇","date":"2020-03-27T14:54:39.481Z","path":"2020/03/27/python之爬虫(1)/","text":"## robot协议 爬虫的协议，通常是一个robot.txt的文本文件，样例： 123user-agent: *(对任何爬虫有效)disallow:/allow:/public/ python爬虫相关库通用库（http的请求库，提供一系列用于操作的URL的功能）有urlib, urlib3(比前面的更加安全)框架 scrapy（一个为了爬取网站数据，提取结构性数据而编写的应用框架）HTML/XML解析器lxml c语言编写高效的HTML/XML处理库，支持XPathBeautifulSoup4 纯python实现的处理库，效率相对比较低 requests库的用法r = requests.get(url, pararms = None, **kwargs);返回的对象叫做Response，他有五个常用的属性r.status_code (http请求的返回状态，200可，404不可)r.text (http的字符串形式)r.encoding( 网页的编码方式,从header中猜测的）r.apparent_encoding( 同上，但是是从内容中猜测出来的)r.content (http响应内容的二进制形式） 爬取实例： 123456789import requestsurl = \"https://pro.jd.com/mall/active/3MEfvhssijcjGZDTHksFm1xnSoEF/index.html\"try: r = requests.get(url) r.raise_for_status(); r.encoding = r.apparent_encoding print( r.text );except: print(\"爬取失败\"); 如果是亚马逊的话会遇到遇到问题，用如下代码即可： 12345678910111213141516import requestsurl = \"https://www.amazon.cn/dp/B001SUAH2M?ref_=\\Oct_DLandingS_D_203565d7_60&amp;smid=A26HDXW89ZT98L\"try: r = requests.get(url) r.raise_for_status(); r.encoding = r.apparent_encoding print( r.text );except: print(\"爬取失败\"); print(r.request.headers) kv = &#123;'User-Agent': 'Mozilla/5.0'&#125; r = requests.get(url, headers = kv); r.encoding = r.apparent_encoding print(\"再次爬取成功！\") print( r.text ); 那么我们如果要向百度提交关键词然后让它返回一个怎么做呢？12345678910import requestskeyword = \"Python\"try: kv = &#123;'wd':keyword&#125; r = requests.get(\"https://www.baidu.com/s\", params=kv) print(r.request.url) r.raise_for_status() print(len(r.text))except: print(\"爬取失败\") 爬取图片1234567891011121314151617181920import requestsimport osurl = \"https://timgsa.baidu.com/timg?image&amp;\\quality=80&amp;size=b9999_10000&amp;sec=1585312263330&amp;di=f552ebc36177\\d93453c888f6587e503e&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitan\\g.com%2Fuploads%2Fitem%2F201812%2F08%2F20181208111719_rzyuy.thumb.700_0.jpg\"path = \"D://abc.jpg\"#path = root + url.split('/')[-1]try: if not os.path.exists(path): r = requests.get(url) with open(path, 'wb') as f: f.write(r.content) f.close() print(\"文件保存成功\") else: print(\"文件已经存在\") except: print(\"爬取失败\") 解析ip地址归属地123456789import requestsurl = \"http://m.ip138.com/ip.asp?ip=\"try: r = requests.get(url+'IP地址') r.raise_for_status() r.encoding = r.apparent_ending print(r.text[-500:0])except: print(\"爬取失败\");","tags":[{"name":"python爬虫","slug":"python爬虫","permalink":"http://yoursite.com/tags/python%E7%88%AC%E8%99%AB/"}]},{"title":"C++(3)","date":"2020-03-25T14:19:06.565Z","path":"2020/03/25/C++(3)/","text":"# 学习总结(3) 封装示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142//封装两层含义//1. 属性和行为合成一个整体//2. 访问控制，现实事物本身有些属性和行为是不对外开放class Person&#123;//人具有的行为(函数)public: void Dese()&#123; cout &lt;&lt; \"我有钱，年轻，个子又高，就爱嘚瑟!\" &lt;&lt; endl;&#125;//人的属性(变量)public: int mTall; //多高，可以让外人知道protected: int mMoney; // 有多少钱,只能儿子孙子知道private: int mAge; //年龄，不想让外人知道&#125;;int main()&#123; Person p; p.mTall = 220; //p.mMoney 保护成员外部无法访问 //p.mAge 私有成员外部无法访问 p.Dese(); return EXIT_SUCCESS;&#125;struct 和 class 的区别class默认访问权限为private,struct默认访问权限为publicclass A&#123; int mAge;&#125;;struct B&#123; int mAge;&#125;;void test()&#123; A a; B b; //a.mAge; //无法访问私有成员 b.mAge; //可正常外部访问&#125; 将成员变量设置成private1.就是你在访问这个对象的时候就不用考虑是不是要加(),因为你一旦设置成private,那么类似name.something的内容就访问不到了，只能用函数来访问，那毫无疑问是要（）2.我们可以把我们的访问变得很精细代码如下: 123456789101112131415class AccessLevels&#123;public: //对只读属性进行只读访问 int getReadOnly()&#123; return readOnly; &#125; //对读写属性进行读写访问 void setReadWrite(int val)&#123; readWrite = val; &#125; int getReadWrite()&#123; return readWrite; &#125; //对只写属性进行只写访问 void setWriteOnly(int val)&#123; writeOnly = val; &#125;private: int readOnly; //对外只读访问 int noAccess; //外部不可访问 int readWrite; //读写访问 int writeOnly; //只写访问&#125;; 对象的构造和析构（概念理解）初始化和清理简单来说就是对一个对象进行初始化和清理，因为是必须要做的，所以编译器会自动处理的，这两个叫做构造函数和析构函数示例： 1234567891011121314151617181920212223242526class Person&#123;public: Person()&#123; //构造函数 cout &lt;&lt; \"构造函数调用!\" &lt;&lt; endl; pName = (char*)malloc(sizeof(\"John\")); strcpy(pName, \"John\"); mTall = 150; mMoney = 100; &#125; ~Person()&#123; //析构函数 cout &lt;&lt; \"析构函数调用!\" &lt;&lt; endl; if (pName != NULL)&#123; free(pName); pName = NULL; &#125; &#125;public: char* pName; int mTall; int mMoney;&#125;;void test()&#123; Person person; cout &lt;&lt; person.pName &lt;&lt; person.mTall &lt;&lt; person.mMoney &lt;&lt; endl;&#125; 要注意的是这两个函数一定要public才可以1.在调用默认构造函数的时候，不要加()示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Person&#123;public: Person()&#123; cout &lt;&lt; \"no param constructor!\" &lt;&lt; endl; mAge = 0; &#125; //有参构造函数 Person(int age)&#123; cout &lt;&lt; \"1 param constructor!\" &lt;&lt; endl; mAge = age; &#125; //拷贝构造函数(复制构造函数) 使用另一个对象初始化本对象 Person(const Person&amp; person)&#123; cout &lt;&lt; \"copy constructor!\" &lt;&lt; endl; mAge = person.mAge; &#125; //打印年龄 void PrintPerson()&#123; cout &lt;&lt; \"Age:\" &lt;&lt; mAge &lt;&lt; endl; &#125;private: int mAge;&#125;;//1. 无参构造调用方式void test01()&#123; //调用无参构造函数 Person person1; person1.PrintPerson(); //无参构造函数错误调用方式 //Person person2(); //person2.PrintPerson();&#125;//2. 调用有参构造函数void test02()&#123; //第一种 括号法，最常用 Person person01(100); //直接把数字传进去初始化就行 person01.PrintPerson(); //调用拷贝构造函数 Person person02(person01); //相当于克隆人一样，把所有的属性全部拷贝好 person02.PrintPerson(); //第二种 匿名对象(显示调用构造函数) Person(200); //匿名对象，没有名字的对象， 但是要注意的是拷贝函数不可以这么写， 具体的看下面的调用 Person person03 = Person(300); person03.PrintPerson(); //注意: 使用匿名对象初始化判断调用哪一个构造函数，要看匿名对象的参数类型 Person person06(Person(400)); //等价于 Person person06 = Person(400); person06.PrintPerson(); //第三种 =号法 隐式转换 Person person04 = 100; //Person person04 = Person(100) person04.PrintPerson(); //调用拷贝构造 Person person05 = person04; //Person person05 = Person(person04) person05.PrintPerson();&#125; 注意：拷贝的时候一定要有变量来接，如果没有变量来接的话，编译器会认为你的A(B) 等价于A B 总而言之，就是不能单独用拷贝构造函数来初始化，一定要当右值。（一定要有人接） 拷贝构造函数调用时机1、用已经创建好的对象来初始化新的对象2、以值传递的方式给函数参数传值3、以值方式返回局部对象release 默认下会做优化 构造函数的调用规则：默认情况下，c++编译器至少为我们写的类增加3个函数1．默认构造函数(无参，函数体为空)2．默认析构函数(无参，函数体为空)3．默认拷贝构造函数，对类中非静态成员属性简单值拷贝4.如果提供了有参的构造，那么系统就不会提供默认的构造了，但是会提供拷贝构造5.如果提供了拷贝构造函数，那么系统就不会提供其他构造函数了 深拷贝和浅拷贝一句话概括就是：浅拷贝是系统默认的，如果你拷贝的对象里面用了malloc那么这一块地方在最后释放的时候会被释放两次，深拷贝就是，自己构建一个拷贝构造函数，拷贝的时候会另外往堆空间借一块地址，那么也就不会出先重复释放的问题了。 12345678910111213141516171819202122232425262728class Person&#123;public: Person(char* name,int age)&#123; pName = (char*)malloc(strlen(name) + 1); strcpy(pName,name); mAge = age; &#125; //增加拷贝构造函数 Person(const Person&amp; person)&#123; pName = (char*)malloc(strlen(person.pName) + 1); strcpy(pName, person.pName); mAge = person.mAge; &#125; ~Person()&#123; if (pName != NULL)&#123; free(pName); &#125; &#125;private: char* pName; int mAge;&#125;;void test()&#123; Person p1(\"Edward\",30); //用对象p1初始化对象p2,调用c++提供的默认拷贝构造函数 Person p2 = p1;&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C++(2)","date":"2020-03-24T14:44:00.955Z","path":"2020/03/24/C++(2)/","text":"# C++学习 引用（reference)引用的本质其实是一个指针常量 int * const p ,意思就是p所做指向的地址是不可以改变的，也就是指针本身就是一个常量，还有一种容易混淆的，叫做常量指针 const int *p, 这种指针表示的是指向的内容不可以改变，所以就好像这个指针指向了一个“常量”一样。例子： 1234567int main()&#123; char * const str = \"apple\"; *str = \"orange\"; cout&lt;&lt;str&lt;&lt;endl; getchar();&#125; 判断以上程序是否可行，答案是不行 1234567int main()&#123; char *const str = \"apple\"; str = \"apple\"; cout&lt;&lt;str&lt;&lt;endl; getchar();&#125; 这样写也是不行额，正确的应该如下 1234567int main()&#123; char * str =\"apple\"; str = \"orange\"; cout&lt;&lt;str&lt;&lt;endl; getchar();&#125; 因为引用就是一个指针常量，所以它的指向自然也是不能改变的，那么，我们可以对数组建立一个引用吗？如同这样的写法： 12int arr[10];int&amp; ref[10] = arr; //这种写法是错误的； 正确的写法如下： 1int(&amp;f)[10] = arr; 检测： 123456789for( int i=0; i&lt;10; ++i)&#123; f[i] = i;&#125;for ( int i=0; i&lt;10; ++i)&#123; cout&lt;&lt;arr[i]&lt;&lt;\" \";&#125;cout &lt;&lt; endl; 接下我们来看一下在函数的传递中如何用引用，在以往没有引用概念的时候，我们需要往函数里面传递参数一般是两种办法1.值传递 2.地址传递这两种传递的区别不言而喻，但是现在如果用引入的话，代码如下： 1234567891011void referenceSwap(int&amp; m, int&amp; n)&#123; int temp = m; m = n; n = temp; //可以发现比起指针，这种写法要方便快捷的多&#125;void test()&#123; int a = 10; b = 20; referenceSwap( a, b);&#125; 再来看一下函数的返回值情况 12345int&amp; testfun01()&#123; int a = 10; return a; &#125; 这种做法是不行的，因为我们说过不能返回局部变量的地址值但是局部的静态变量是被允许的 123456int&amp; testfunc02()&#123; static int a = 20; cout &lt;&lt; \"static int a:\" &lt;&lt; a &lt;&lt; endl; return a;&#125; 而且这个返回值，是可以做左值的。即： 1testfunc02() = 100; //换而言之，函数要做左值必须换回引用 指针引用一句话我觉得特别的好，改变一个指向的内容用一级指针，如果要改变一个指针的指向那么可以使用二级指针那么在没有引用之前，我们会这么写： 12void fun(int **);int ** p; 学习了引用之后，我们也可以把二级指针写成这个样子： 12int* pointer = NULL;int*&amp; p = pointer; 一下是一个具体的例子： 123456789101112131415161718192021222324struct Teacher&#123; int age;&#125;//use pointer change the teacher's agevoid func01( Teacher ** teacher)&#123; *teacher = (Teacher*)malloc(sizeof(Teacher)); *teacher-&gt;age = 200;&#125;//use reference change age;void func02( Teacher*&amp; teacher)&#123; teacher-&gt;age = 200; //甚至不需要malloc堆空间，因为引用的指向的地址是不可以改变的&#125;void test()&#123; Teacher* teacher = NULL; func01( &amp;teacher ); func02( teacher ); //可见，c++中是引用，非常的方便，因为取地址这一步，已经完全别不用了&#125; 我对于引用的理解就是，解决了往函数中传递参数的复杂性。 内联函数的概念在这里不做处理默认参数函数的默认参数：在定义或者声明的时候直接把数值写好 1void testfun01( int a=0; int b=0) 注意：1.要是声明里面写了数值，那么在函数定义的时候就不能写数字了。2.void testfun02( int a; int b=8; int c=8) 要是前面的写了，那后面的一定要写3.如果没有穿参数，那就使用默认的参数4.如果传入一个参数，那么第二个参数使用默认参数5.都传入了，那就用传入的 占位参数1void testfun( int a, int b, int) 值得注意的是：1.不管默认参数设置不设置默认值，在函数内部都不能用2.传参数的时候一定要确保往默认参数里传值那声明时候用呢？后面操作符重载的后置++会用到，拭目以待。 函数重载（overload）在传统c语言中，函数名必须是唯一的，程序中不允许出现同名的函数。在c++中是允许出现同名的函数，这种现象称为函数重载。(一词多义)目的：方便的使用函数名再往直白的说，其实就是重新定义一个函数，名字可以和之前的一样，但是要注意一下要求：1.同一个作用域2.参数的个数不能一样3.参数的类型不能一样4.参数的顺序不能一样 （后三个条件按应该是满足其中一个就可以了） 但是如果有默认参数的话，要特别注意下面的情况： 123void MyFunc(string b)&#123; cout &lt;&lt; \"b: \" &lt;&lt; b &lt;&lt; endl;&#125; 12345678//函数重载碰上默认参数void MyFunc(string b, int a = 10)&#123; cout &lt;&lt; \"a: \" &lt;&lt; a &lt;&lt; \" b:\" &lt;&lt; b &lt;&lt; endl;&#125;int main()&#123; MyFunc(\"hello\"); //这时，两个函数都能匹配调用，产生二义性 return 0;&#125; 注意：这个时候会产生二义性 函数重载实现原理编译器为了实现函数重载，也是默认为我们做了一些幕后的工作，编译器用不同的参数类型来修饰不同的函数名，比如void func(); 编译器可能会将函数名修饰成_func，当编译器碰到void func(int x),编译器可能将函数名修饰为_func_int,当编译器碰到void func(int x,char c),编译器可能会将函数名修饰为_func_int_char我这里使用”可能”这个字眼是因为编译器如何修饰重载的函数名称并没有一个统一的标准，所以不同的编译器可能会产生不同的内部名。 extern c由于c++中需要支持函数重载，所以c和c++中对同一个函数经过编译后生成的函数名是不相同的，这就导致了一个问题，如果在c++中调用一个使用c语言编写模块中的某个函数，那么c++是根据c++的名称修饰方式来查找并链接这个函数，那么就会发生链接错误，那么如果我想在c++调用c的函数怎么办？extern “C”的主要作用就是为了实现c++代码能够调用其他c语言代码。加上extern “C”后，这部分代码编译器按c语言的方式进行编译和链接，而不是按c++的方式。 只需要再头文件中添加这段代码就可以做到： 1234567891011121314151617#ifndef MYMODULE_H#define MYMODULE_H#include&lt;stdio.h&gt;#if __cplusplus extern \"C\"&#123;#endif void func1(); //把C的函数写在这个中间，然后再文件中调用这个头文件就可以了 int func2(int a,int b);#if __cplusplus&#125;#endif#endif 封装封装包含了两个特性：1.一个是属性和变量变成了一个整体2.给函数和属性增加了访问的权限","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C++(1)","date":"2020-03-23T15:11:51.500Z","path":"2020/03/23/C++(1)/","text":"1. 数据结构—队列队列是典型的 FIFO 数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在队列的末尾。 删除（delete）操作也被称为出队（dequeue)。 你只能移除第一个元素。下图是描述队列的基本模型： 然而，一般的队列效率是低下的，一种更加有效的方式是循环队列，具体来说，我们可以使用固定大小的数组和两个指针来指示起始位置和结束位置。 目的是重用我们之前提到的被浪费的存储。 1.1 C++代码实现（循环队列）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class MyCircularQueue &#123;private: vector&lt;int&gt; data; int head; //定义头 int tail; //定义尾巴 int size; //定义大小public: /** Initialize your data structure here. Set the size of the queue to be k. */ MyCircularQueue(int k) &#123; //初始化 data.resize(k); head = -1; tail = -1; size = k; &#125; /** Insert an element into the circular queue. Return true if the operation is successful. */ bool enQueue(int value) &#123; if (isFull()) &#123; return false; &#125; if (isEmpty()) &#123; head = 0; &#125; tail = (tail + 1) % size; //关键操作：循环的一种算法 data[tail] = value; return true; &#125; /** Delete an element from the circular queue. Return true if the operation is successful. */ bool deQueue() &#123; if (isEmpty()) &#123; return false; &#125; if (head == tail) &#123; head = -1; tail = -1; return true; &#125; head = (head + 1) % size; //循环算法 return true; &#125; /** Get the front item from the queue. */ int Front() &#123; if (isEmpty()) &#123; return -1; &#125; return data[head]; &#125; /** Get the last item from the queue. */ int Rear() &#123; if (isEmpty()) &#123; return -1; &#125; return data[tail]; &#125; /** Checks whether the circular queue is empty or not. */ bool isEmpty() &#123; return head == -1; //头为-1判断是否为空 &#125; /** Checks whether the circular queue is full or not. */ bool isFull() &#123; return ((tail + 1) % size) == head; //（尾+1）/大小，可以判断是否为满 &#125;&#125;; 由于c++中有库可以调用所以不必重复的造轮子。 123456789101112131415161718192021222324#include &lt;iostream&gt;int main() &#123; // 1. Initialize a queue. queue&lt;int&gt; q; // 2. Push new element. q.push(5); q.push(13); q.push(8); q.push(6); // 3. Check if queue is empty. if (q.empty()) &#123; cout &lt;&lt; \"Queue is empty!\" &lt;&lt; endl; return 0; &#125; // 4. Pop an element. q.pop(); // 5. Get the first element. cout &lt;&lt; \"The first element is: \" &lt;&lt; q.front() &lt;&lt; endl; // 6. Get the last element. cout &lt;&lt; \"The last element is: \" &lt;&lt; q.back() &lt;&lt; endl; // 7. Get the size of the queue. cout &lt;&lt; \"The size is: \" &lt;&lt; q.size() &lt;&lt; endl;&#125; 关于队列的用法和实例，将在明天的博文中实现。 2. C++语言学习（day01)2.1 面向对象编程的概念在面向过程的编程中，程序 = 数据结构+算法。 在面向对象的编程中，对象 = 数据结构+算法， 程序 = 对象+对象+...2.2 面向编程的三大特性1.封装（把客观事物抽象成一个类） 2.继承（避免代码的复用，减少代码和数据冗余） 3.多态（一个接口，多种方法）2.3 C++对C的扩展2.3.1 ::作用域运算符作用域运算符可以解决局部变量和全局变量的重名问题 12345678910//全局变量int a = 10;//1. 局部变量和全局变量同名void test()&#123; int a = 20; //打印局部变量a cout &lt;&lt; \"局部变量a:\" &lt;&lt; a &lt;&lt; endl; //打印全局变量a cout &lt;&lt; \"全局变量a:\" &lt;&lt; ::a &lt;&lt; endl;&#125; ==使用::可以对同名的全局变量进行访问== 2.3.2 namespace命名空间==个人的理解就好比一个记忆宫殿，每一个房间里面都有自己的变量和函数，当你需要用的时候把这个空间打开，就可以使用里面的变量了。== 123456789101112131415161718192021namespace A&#123; int a = 10;&#125;namespace A&#123; void func()&#123; cout &lt;&lt; \"hello namespace!\" &lt;&lt; endl; &#125;&#125;void test()&#123; cout &lt;&lt; \"A::a : \" &lt;&lt; A::a &lt;&lt; endl; A::func();&#125;//用途 解决名称冲突问题//必须在全局作用域下声明//命名空间下可以放入 函数、变量、结构体、类…//命名空间可以嵌套命名空间//命名空间是开放的，可以随时加入新的成员//匿名命名空间 static//可以起别名 2.3.3 using声明==using声明可以使一些标识符可用== 1234567891011121314151617181920namespace A&#123; int paramA = 20; int paramB = 30; void funcA()&#123; cout &lt;&lt; \"hello funcA\" &lt;&lt; endl; &#125; void funcB()&#123; cout &lt;&lt; \"hello funcA\" &lt;&lt; endl; &#125;&#125;void test()&#123; //1. 通过命名空间域运算符 cout &lt;&lt; A::paramA &lt;&lt; endl; A::funcA(); //2. using声明 using A::paramA; using A::funcA; cout &lt;&lt; paramA &lt;&lt; endl; //cout &lt;&lt; paramB &lt;&lt; endl; //不可直接访问 funcA(); //3. 同名冲突 //int paramA = 20; //相同作用域注意同名冲突&#125; 2.4 C++对C的增强2.4.1 struct 类型加强 c中定义结构体变量需要加上struct关键字，c++不需要。 c中的结构体只能定义成员变量，不能定义成员函数。c++即可以定义成员变量，也可以定义成员函数。 123456789101112131415161718//1. 结构体中即可以定义成员变量，也可以定义成员函数struct Student&#123; string mName; int mAge; void setName(string name)&#123; mName = name; &#125; void setAge(int age)&#123; mAge = age; &#125; void showStudent()&#123; cout &lt;&lt; \"Name:\" &lt;&lt; mName &lt;&lt; \" Age:\" &lt;&lt; mAge &lt;&lt; endl; &#125;&#125;;//2. c++中定义结构体变量不需要加struct关键字void test01()&#123; Student student; student.setName(\"John\"); student.setAge(20); student.showStudent();&#125; 2.4.2 三目运算符的增强 C中的三目运算符是右值，不可以赋值。 C++ 中三目运算符的结果可以做左值。 2.4.3 C++中的const c++中对于局部的const变量要区别对待：对于基础数据类型，也就是const int a = 10这种，编译器会把它放到==符号表==中，不分配内存，当对其取地址时，会分配内存。 123456789const int constA = 10;int* p = (int*)&amp;constA;*p = 300;cout &lt;&lt; \"constA:\" &lt;&lt; constA &lt;&lt; endl;cout &lt;&lt; \"*p:\" &lt;&lt; *p &lt;&lt; endl;运行结果：constA:10*p:300 constA在符号表中，当我们对constA取地址，==这个时候为constA分配了新的空间，*p操作的是分配的空间，而constA是从符号表获得的值。== c中const默认为外部连接，c++中const默认为内部连接.当c语言两个文件中都有const int a的时候，编译器会报重定义的错误。而在c++中，则不会，因为c++中的const默认是内部连接的。如果想让c++中的const具有外部连接，必须显示声明为: extern const int a = 10; 2.4.4 尽量使用const来代替宏定义const和#define区别总结: const有类型，可进行编译器类型安全检查。#define无类型，不可进行类型检查. const有作用域，而#define不重视作用域，默认定义处到文件结尾.如果定义在指定作用域下有效的常量，那么#define就不能用。 123#define MAX 1024//使用const代替上面的宏#const int max = 1024","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C进阶（1）","date":"2020-03-22T03:45:46.000Z","path":"2020/03/22/c进阶/","text":"C进阶-知识点整理C语言进阶篇，是个人的知识点梳理，没有基础篇，适合给已经学会C但是需要跟进的童鞋阅读。本篇持续更新，内容基于作者理解撰写，有争议处尽情指出。 你必须要有的概念C语言是一门“低级”的高级语言，最重要的最灵活的应该就是它的指针了，这玩意可以说是可以看实力的，但是要理解和用好指针，对于操作系统和内存的理解一定是不能少的： C语言可以使用的函数其实可以分为系统函数和标准库函数，那么我们平时用的如#include&lt;stdio.h&gt;库就是属于标准的输入输出库，那么一定有人会问：这两个种类型的库有什么区别的呢？区别在于：系统库的可移植性差，假设你用windows调用系统库写一段代码， 再粘贴到Linux的操作系统上面，那编译就会错，所以标准的库应运而生，它具有可以适应多操作系统的能力。 学操作系统就是学操作系统函数的接口。 用不同的C语言的标准比如C89和C99两种标准不同，带代码的注意事项也会不同。 一、typedef 用法这里展示一些typedef的用法： 123451.typedef struct Person&#123;&#125; myperson; //给结构体命名2.char *p1, p2; //如果这样定义的话，p1是指针，而p2是字符3.typedef char* pchar pchar p1,p2; //这种方法即可定义p1,p2都是指针了4.typedef int mytype_int //可以方便的管理变量的类型 二、sizeof() 用法sizeof() 返回的是占用空间的大小，单位是字节，返回值的类型是unsigned int ,这都是需要注意的地方，一下展示一部分用法。 1234567891011121. int func( int * p)2. &#123;3. printf(\"sizeof(p) = %d\\n\", sizeof( p )); //在此处打印的是4个字节4. return sizeof(p);5. &#125;6. int main()7. &#123;8. int arr[] = &#123;1,2,3,4,5,6,7&#125;;9. printf(\"sizeof(arr) = %d\\n\", arr); //这样输出的结果是28个字节10. int p = func( arr );11. printf(\"p = %d\\n\", p); //这里打印的也是4个字节12. &#125; 三、内存四区 程序在没有被加载的时候，只存在代码区和数据区。 12345678910#include&lt;stdio.h&gt;int a; //全局区，这里的变量其他文件中只要声明，也可以使用extern int a; //同上, 这是上面的完整写法static int a; //静态区 这里的变量只能在当前的文件中使用const int a; //常量区 int main()&#123; char *s = \"hello world!\"; //常量区，只读&#125; 一旦你的程序从你的磁盘被加载到内存，那么堆区和栈区也会出现123int a = 10; //这种操作就是在栈上得到了一块空间,会自动释放int *p = malloc( sizeof(int)*4 ); //这是在堆上借一块内存空间，用完要自己释放free( p ); 四、变量的生命周期切记不要去操控已经被回收的空间 12345678910int *myfunc()&#123; int a = 10; return &amp;a;&#125;void test()&#123; int *p = myfunc(); //这个时候a这块空间已经被回收了，因此是不能去操控的 printf(\"*p = %d\\n\", *p);//结果可能是10，因为这块地址上的值还没有被修改，但是是很不安全的&#125;","tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"wjj喜欢fhz-hello","date":"2020-03-21T08:38:24.000Z","path":"2020/03/21/wjj喜欢小贞贞/","text":"小贞贞你好这是我的私人博客， 欢迎光临呀~它能干什么？我还没想好，不过这篇文章将于博客共存亡。常来哦~","tags":[{"name":"mylove","slug":"mylove","permalink":"http://yoursite.com/tags/mylove/"}]}]